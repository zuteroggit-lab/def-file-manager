<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Def File Manager 1.0</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#f7f7fb; --panel:#fff; --muted:#6b7280; --accent:#2563eb; --danger:#e11d48;
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;color:#111}
    .app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
    .sidebar{width:380px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(16,24,40,0.06);overflow:auto}
    .main{flex:1;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(16,24,40,0.06);display:flex;flex-direction:column;overflow:hidden}
    .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
    button{background:var(--accent);color:#fff;border:0;padding:8px 10px;border-radius:8px;cursor:pointer}
    button.ghost{background:transparent;color:var(--accent);border:1px solid rgba(37,99,235,0.12)}
    #tree{font-size:14px;line-height:1.6}
    .node{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;user-select:none;position:relative}
    .node:hover{background:rgba(37,99,235,0.04)}
    .node.selected{background:rgba(37,99,235,0.12);box-shadow:inset 0 0 0 1px rgba(37,99,235,0.06)}
    .node.dragover{outline:2px dashed rgba(37,99,235,0.45);border-radius:8px}
    .node .label{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .children{margin-left:18px}
    .toggle{width:18px;height:18px;display:inline-flex;align-items:center;justify-content:center;cursor:pointer;color:var(--muted)}
    .icon{width:18px;height:18px;flex:0 0 18px}
    .viewer{flex:1;overflow:auto;padding:12px;border-radius:10px;background:#fbfdff;border:1px solid rgba(16,24,40,0.03)}
    .file-content{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace;font-size:13px;color:#111}
    .meta{font-size:13px;color:var(--muted);margin-bottom:8px}
    .empty{color:var(--muted);padding:12px}
    #searchInput{flex:1;padding:8px;border-radius:8px;border:1px solid #e6e9ee}
    .small{padding:6px 8px;font-size:13px}
    .breadcrumb{display:flex;gap:6px;align-items:center;font-size:13px;margin-bottom:8px}
    .crumb{color:var(--accent);cursor:pointer}
    .crumb.inactive{color:var(--muted);cursor:default}
    .bulk-info{font-size:13px;color:var(--muted);margin-left:auto}
    /* Modal */
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:60}
    .modal{width:min(900px,95%);background:#fff;border-radius:10px;padding:12px;box-shadow:0 12px 40px rgba(16,24,40,0.2);max-height:90vh;display:flex;flex-direction:column}
    .modal-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    .modal-title{font-weight:600}
    .modal-body{flex:1;display:flex;flex-direction:column;gap:8px}
    .modal textarea{width:100%;height:60vh;padding:10px;border-radius:8px;border:1px solid #e6e9ee;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace;font-size:13px;resize:vertical}
    .modal-footer{display:flex;gap:8px;justify-content:flex-end;margin-top:8px}
    .hint{font-size:12px;color:var(--muted)}
    /* Context menu */
    .ctx-menu{position:fixed;background:#fff;border:1px solid rgba(16,24,40,0.06);box-shadow:0 8px 30px rgba(16,24,40,0.08);border-radius:8px;padding:6px;z-index:120;display:none;min-width:160px}
    .ctx-item{padding:8px 10px;border-radius:6px;cursor:pointer;color:#111}
    .ctx-item:hover{background:rgba(16,24,40,0.04)}
    .ctx-item.danger{color:var(--danger)}
    /* Drag ghost */
    .drag-ghost{position:fixed;pointer-events:none;z-index:200;transform:translate(-50%,-50%);background:rgba(16,24,40,0.9);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px}
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <div class="toolbar">
        <button id="btnNewFile" class="small">Создать файл</button>
        <button id="btnNewFolder" class="small ghost">Создать папку</button>
        <button id="btnEdit" class="small">Редактировать</button>
        <button id="btnRename" class="small ghost">Переименовать</button>
        <button id="btnDelete" class="small ghost">Удалить</button>
        <div class="bulk-info" id="bulkInfo">Выбрано: 0</div>
      </div>

      <div class="toolbar" style="margin-top:8px">
        <input id="searchInput" type="search" placeholder="Поиск файлов и папок" />
        <button id="btnClearSearch" class="small ghost">Очистить</button>
      </div>

      <div style="display:flex;gap:8px;margin:8px 0">
        <button id="btnExport" class="small ghost">Экспорт JSON</button>
        <label class="small ghost" style="padding:6px 8px;border-radius:6px;cursor:pointer">
          Импорт JSON
          <input id="importInput" type="file" accept=".json" style="display:none">
        </label>
        <button id="btnMoveSelected" class="small ghost">Переместить выбранные</button>
        <button id="btnDeleteSelected" class="small ghost">Удалить выбранные</button>
      </div>

      <div id="tree" aria-label="Файловое дерево"></div>
    </div>

    <div class="main">
      <div class="breadcrumb" id="breadcrumbBar" aria-hidden="false">
        <div class="crumb inactive">/</div>
      </div>
      <div class="meta" id="pathBar">Путь: /</div>
      <div class="viewer" id="viewer">
        <div class="empty">Выберите файл или папку слева</div>
      </div>
    </div>
  </div>

  <!-- SVG icons -->
  <svg style="display:none" aria-hidden="true">
    <symbol id="icon-folder" viewBox="0 0 24 24">
      <path fill="#F6C94C" d="M10 4H4a2 2 0 0 0-2 2v2h20V8a2 2 0 0 0-2-2h-8l-2-2z"/>
      <path fill="#E6B93A" d="M2 10v8a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-8H2z"/>
    </symbol>
    <symbol id="icon-txt" viewBox="0 0 24 24">
      <path fill="#FFFFFF" d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
      <path fill="#E6E9EE" d="M14 2v6h6"/>
      <path fill="#2D3748" d="M8 12h8v1H8zM8 15h8v1H8zM8 18h5v1H8z"/>
    </symbol>
    <symbol id="icon-chevron" viewBox="0 0 24 24">
      <path fill="currentColor" d="M9 6l6 6-6 6"/>
    </symbol>
  </svg>

  <!-- Editor modal -->
  <div id="editorModal" style="display:none">
    <div class="modal-backdrop" id="modalBackdrop">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="modal-header">
          <div class="modal-title" id="modalTitle">Редактировать файл</div>
          <div class="hint" id="modalPath">/root/...</div>
        </div>
        <div class="modal-body">
          <textarea id="editorTextarea" spellcheck="false"></textarea>
          <div class="hint" id="autosaveHint">Автосохранение: выключено</div>
        </div>
        <div class="modal-footer">
          <button id="btnSaveEdit" class="small">Сохранить</button>
          <button id="btnUndo" class="small ghost">Отменить (Ctrl+Z)</button>
          <button id="btnRedo" class="small ghost">Повтор (Ctrl+Y)</button>
          <button id="btnCancelEdit" class="small ghost">Отмена</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Context menu -->
  <div id="ctxMenu" class="ctx-menu" role="menu">
    <div class="ctx-item" data-action="new-file">Создать файл</div>
    <div class="ctx-item" data-action="new-folder">Создать папку</div>
    <div class="ctx-item" data-action="rename">Переименовать</div>
    <div class="ctx-item" data-action="delete">Удалить</div>
    <div class="ctx-item" data-action="move">Переместить</div>
  </div>

  <!-- Drag ghost -->
  <div id="dragGhost" class="drag-ghost" style="display:none"></div>

  <script>
    /*************************************************************************
     * Core data and utilities
     *************************************************************************/
    let fileSystem = {
      "name": "root",
      "type": "folder",
      "children": [
        {
          "name": "docs",
          "type": "folder",
          "children": [
            { "name": "readme.txt", "type": "file", "content": "Добро пожаловать в Def File Manager 1.0!\n\nЭто тестовый файл." },
            { "name": "manual.txt", "type": "file", "content": "Инструкция: двойной клик — редактировать." }
          ]
        },
        {
          "name": "images",
          "type": "folder",
          "children": [
            { "name": "logo.png", "type": "file", "content": "<binary image placeholder>" }
          ]
        }
      ]
    };

    const treeRoot = document.getElementById('tree');
    const viewer = document.getElementById('viewer');
    const pathBar = document.getElementById('pathBar');
    const searchInput = document.getElementById('searchInput');
    const breadcrumbBar = document.getElementById('breadcrumbBar');
    const bulkInfo = document.getElementById('bulkInfo');

    const editorModal = document.getElementById('editorModal');
    const modalBackdrop = document.getElementById('modalBackdrop');
    const editorTextarea = document.getElementById('editorTextarea');
    const modalPath = document.getElementById('modalPath');
    const autosaveHint = document.getElementById('autosaveHint');

    const ctxMenu = document.getElementById('ctxMenu');
    const dragGhost = document.getElementById('dragGhost');
    const importInput = document.getElementById('importInput');

    let lastSelectedPath = '/root';
    let lastSelectedNode = null;

    const selectedPaths = new Set();
    let flattenedList = [];
    let lastClickedIndex = -1;

    const editHistory = {};
    const AUTOSAVE_INTERVAL = 3000;
    let autosaveTimer = null;

    /*************************************************************************
     * Persistence
     *************************************************************************/
    function saveFS() {
      try {
        localStorage.setItem('def_file_system', JSON.stringify(fileSystem));
        console.log('FS saved');
      } catch (e) { console.error('Save failed', e); }
    }

    function loadFS() {
      try {
        const raw = localStorage.getItem('def_file_system');
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed && parsed.type === 'folder') fileSystem = parsed;
        }
      } catch (e) { console.error('Load failed', e); }
    }

    /*************************************************************************
     * Tree helpers
     *************************************************************************/
    function findNodeByPath(path) {
      const parts = path.split('/').filter(Boolean);
      if (parts.length === 0) return null;
      let cur = fileSystem;
      if (parts[0] !== fileSystem.name) return null;
      for (let i = 1; i < parts.length; i++) {
        if (!cur.children) return null;
        cur = cur.children.find(c => c.name === parts[i]);
        if (!cur) return null;
      }
      return cur;
    }

    function findParentAndIndex(path) {
      const parts = path.split('/').filter(Boolean);
      if (parts.length <= 1) return { parent: null, index: 0 };
      let cur = fileSystem;
      for (let i = 1; i < parts.length - 1; i++) {
        cur = cur.children.find(c => c.name === parts[i]);
        if (!cur) return null;
      }
      const idx = cur.children.findIndex(c => c.name === parts[parts.length - 1]);
      return { parent: cur, index: idx };
    }

    function moveNode(srcPath, destFolderPath) {
      if (srcPath === destFolderPath) return false;
      const info = findParentAndIndex(srcPath);
      if (!info) return false;
      const node = info.parent.children[info.index];
      if (node.type === 'folder' && destFolderPath.startsWith(srcPath + '/')) return false;
      info.parent.children.splice(info.index, 1);
      const dest = findNodeByPath(destFolderPath);
      if (!dest || dest.type !== 'folder') return false;
      if (!dest.children) dest.children = [];
      dest.children.push(node);
      return true;
    }

    function flattenTree(node = fileSystem, parentPath = '') {
      const list = [];
      const curPath = parentPath + '/' + node.name;
      list.push({ path: curPath, node });
      if (node.type === 'folder' && Array.isArray(node.children)) {
        node.children.forEach(child => list.push(...flattenTree(child, curPath)));
      }
      return list;
    }

    /*************************************************************************
     * UI helpers
     *************************************************************************/
    function createIcon(symbolId){
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('class','icon');
      svg.setAttribute('viewBox','0 0 24 24');
      const use = document.createElementNS('http://www.w3.org/1999/xlink','use');
      use.setAttributeNS('http://www.w3.org/1999/xlink','href','#' + symbolId);
      svg.appendChild(use);
      return svg;
    }

    function renderBreadcrumb(path) {
      const parts = path.split('/').filter(Boolean);
      breadcrumbBar.innerHTML = '';
      const rootCrumb = document.createElement('div');
      rootCrumb.className = 'crumb';
      rootCrumb.textContent = '/';
      rootCrumb.addEventListener('click', () => {
        lastSelectedPath = '/root';
        lastSelectedNode = fileSystem;
        pathBar.textContent = 'Путь: /root';
        refreshTree();
      });
      breadcrumbBar.appendChild(rootCrumb);
      let acc = '';
      parts.forEach((p, i) => {
        acc += '/' + p;
        const sep = document.createElement('div');
        sep.textContent = '›';
        sep.style.color = 'var(--muted)';
        sep.style.margin = '0 6px';
        breadcrumbBar.appendChild(sep);
        const crumb = document.createElement('div');
        crumb.className = i === parts.length - 1 ? 'crumb inactive' : 'crumb';
        crumb.textContent = p;
        crumb.addEventListener('click', () => {
          if (i === parts.length - 1) return;
          lastSelectedPath = acc;
          lastSelectedNode = findNodeByPath(acc);
          pathBar.textContent = 'Путь: ' + acc;
          refreshTree();
        });
        breadcrumbBar.appendChild(crumb);
      });
    }

    function renderBulkInfo(){
      bulkInfo.textContent = 'Выбрано: ' + selectedPaths.size;
    }

    function updateSelectionVisuals() {
      // clear all
      treeRoot.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
      // mark nodes by data-path
      selectedPaths.forEach(p => {
        const el = treeRoot.querySelector(`[data-path="${CSS.escape(p)}"]`);
        if (el) el.classList.add('selected');
      });
    }

    function clearViewer(){
      viewer.innerHTML = '<div class="empty">Выберите файл или папку слева</div>';
      pathBar.textContent = 'Путь: /';
      lastSelectedPath = '/root';
      lastSelectedNode = null;
      renderBreadcrumb('/root');
      selectedPaths.clear();
      renderBulkInfo();
      updateSelectionVisuals();
    }

    /*************************************************************************
     * Render tree with drag&drop, multiselect, context menu
     *************************************************************************/
    function renderTree(node, container, parentPath = '') {
      const currentPath = parentPath + '/' + node.name;
      const item = document.createElement('div');
      item.className = 'node';
      item.setAttribute('data-path', currentPath);

      // drag handlers
      item.setAttribute('draggable', 'true');
      item.addEventListener('dragstart', (ev) => {
        // ensure selection includes this
        if (!selectedPaths.has(currentPath)) {
          selectedPaths.clear();
          selectedPaths.add(currentPath);
          updateSelectionVisuals();
          renderBulkInfo();
        }
        const count = selectedPaths.size;
        // create drag ghost
        dragGhost.textContent = count > 1 ? `${count} элементов` : node.name;
        dragGhost.style.display = 'block';
        // set custom drag image
        const rect = dragGhost.getBoundingClientRect();
        const canvas = document.createElement('canvas');
        canvas.width = Math.max(1, rect.width);
        canvas.height = Math.max(1, rect.height);
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(16,24,40,0.9)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = '12px sans-serif';
        ctx.fillText(dragGhost.textContent, 8, 16);
        ev.dataTransfer.setDragImage(canvas, canvas.width/2, canvas.height/2);
        ev.dataTransfer.setData('text/plain', currentPath);
        ev.dataTransfer.effectAllowed = 'move';
      });

      item.addEventListener('dragend', () => {
        dragGhost.style.display = 'none';
      });

      item.addEventListener('dragover', (ev) => {
        ev.preventDefault();
        const targetNode = findNodeByPath(currentPath);
        if (targetNode && targetNode.type === 'folder') {
          item.classList.add('dragover');
          ev.dataTransfer.dropEffect = 'move';
        } else {
          ev.dataTransfer.dropEffect = 'none';
        }
      });

      item.addEventListener('dragleave', () => item.classList.remove('dragover'));

      item.addEventListener('drop', (ev) => {
        ev.preventDefault();
        item.classList.remove('dragover');
        const destPath = currentPath;
        const destNode = findNodeByPath(destPath);
        if (!destNode || destNode.type !== 'folder') return;
        const toMove = Array.from(selectedPaths).sort((a,b) => b.length - a.length);
        let movedAny = false;
        for (const src of toMove) {
          if (src === destPath) continue;
          if (src.startsWith(destPath + '/')) continue;
          const ok = moveNode(src, destPath);
          if (ok) movedAny = true;
        }
        if (movedAny) {
          saveFS();
          refreshTree();
        }
      });

      // context menu
      item.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        // selection logic on right click
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
        if (!selectedPaths.has(currentPath) && !ctrlKey && !e.shiftKey) {
          selectedPaths.clear();
          selectedPaths.add(currentPath);
          updateSelectionVisuals();
          renderBulkInfo();
        }
        showContextMenu(e.clientX, e.clientY, currentPath);
      });

      // selection (click) with Ctrl/Shift support
      function handleSelect(e, indexInFlat) {
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        const ctrlKey = isMac ? e.metaKey : e.ctrlKey;
        if (e.shiftKey && lastClickedIndex >= 0 && indexInFlat >= 0) {
          const start = Math.min(lastClickedIndex, indexInFlat);
          const end = Math.max(lastClickedIndex, indexInFlat);
          const slice = flattenedList.slice(start, end + 1);
          slice.forEach(s => selectedPaths.add(s.path));
        } else if (ctrlKey) {
          if (selectedPaths.has(currentPath)) selectedPaths.delete(currentPath);
          else selectedPaths.add(currentPath);
          lastClickedIndex = indexInFlat;
        } else {
          selectedPaths.clear();
          selectedPaths.add(currentPath);
          lastClickedIndex = indexInFlat;
        }
        updateSelectionVisuals();
        renderBulkInfo();
        lastSelectedPath = currentPath;
        lastSelectedNode = node;
        pathBar.textContent = 'Путь: ' + currentPath;
        renderBreadcrumb(currentPath);
      }

      // render visuals
      if (node.type === 'folder') {
        const toggle = document.createElement('div');
        toggle.className = 'toggle';
        toggle.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24"><use href="#icon-chevron"></use></svg>';
        toggle.style.transform = 'rotate(0deg)';
        toggle.style.transition = 'transform 0.12s linear';
        item.appendChild(toggle);

        const icon = createIcon('icon-folder');
        item.appendChild(icon);

        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = node.name;
        item.appendChild(label);

        container.appendChild(item);

        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'children';
        childrenContainer.style.display = 'none';
        container.appendChild(childrenContainer);

        item.addEventListener('click', (e) => {
          if (e.target.tagName.toLowerCase() === 'input') return;
          const open = childrenContainer.style.display === 'block';
          childrenContainer.style.display = open ? 'none' : 'block';
          toggle.style.transform = open ? 'rotate(0deg)' : 'rotate(90deg)';
          const indexInFlat = flattenedList.findIndex(x => x.path === currentPath);
          handleSelect(e, indexInFlat);
          e.stopPropagation();
        });

        if (Array.isArray(node.children)) {
          node.children.forEach(child => renderTree(child, childrenContainer, currentPath));
        }
      } else {
        const spacer = document.createElement('div');
        spacer.style.width = '18px';
        item.appendChild(spacer);

        const icon = createIcon('icon-txt');
        item.appendChild(icon);

        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = node.name;
        item.appendChild(label);

        container.appendChild(item);

        item.addEventListener('click', (e) => {
          const indexInFlat = flattenedList.findIndex(x => x.path === currentPath);
          handleSelect(e, indexInFlat);
          viewer.innerHTML = '';
          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.textContent = 'Файл: ' + currentPath;
          viewer.appendChild(meta);
          const content = document.createElement('div');
          content.className = 'file-content';
          content.textContent = node.content || '';
          viewer.appendChild(content);
          e.stopPropagation();
        });

        item.addEventListener('dblclick', (e) => {
          const indexInFlat = flattenedList.findIndex(x => x.path === currentPath);
          handleSelect(e, indexInFlat);
          openEditorForSelected();
          e.stopPropagation();
        });
      }
    }

    /*************************************************************************
     * Refresh tree
     *************************************************************************/
    function refreshTree() {
      flattenedList = flattenTree();
      treeRoot.innerHTML = '';
      renderTree(fileSystem, treeRoot, '');
      const node = findNodeByPath(lastSelectedPath);
      if (!node) clearViewer();
      else {
        pathBar.textContent = 'Путь: ' + lastSelectedPath;
        renderBreadcrumb(lastSelectedPath);
      }
      updateSelectionVisuals();
      renderBulkInfo();
    }

    loadFS();
    refreshTree();

    /*************************************************************************
     * Buttons and actions
     *************************************************************************/
    document.getElementById('btnNewFile').addEventListener('click', () => {
      const name = prompt('Имя нового файла (например note.txt):','new-file.txt');
      if (!name) return;
      const folder = findNodeByPath(lastSelectedPath) || fileSystem;
      const targetFolder = folder.type === 'folder' ? folder : findParentAndIndex(lastSelectedPath).parent || fileSystem;
      if (!targetFolder.children) targetFolder.children = [];
      targetFolder.children.push({name, type:'file', content:''});
      saveFS();
      refreshTree();
    });

    document.getElementById('btnNewFolder').addEventListener('click', () => {
      const name = prompt('Имя новой папки:','new-folder');
      if (!name) return;
      const folder = findNodeByPath(lastSelectedPath) || fileSystem;
      const targetFolder = folder.type === 'folder' ? folder : findParentAndIndex(lastSelectedPath).parent || fileSystem;
      if (!targetFolder.children) targetFolder.children = [];
      targetFolder.children.push({name, type:'folder', children:[]});
      saveFS();
      refreshTree();
    });

    document.getElementById('btnEdit').addEventListener('click', () => openEditorForSelected());

    document.getElementById('btnRename').addEventListener('click', () => {
      if (selectedPaths.size === 0) return alert('Ничего не выбрано');
      if (selectedPaths.size > 1) return alert('Переименование работает только для одного узла');
      const path = Array.from(selectedPaths)[0];
      if (path === '/root') return alert('Нельзя переименовать корень');
      const info = findParentAndIndex(path);
      if (!info) return alert('Узел не найден');
      const node = info.parent ? info.parent.children[info.index] : fileSystem;
      const newName = prompt('Новое имя', node.name);
      if (!newName) return;
      node.name = newName;
      saveFS();
      refreshTree();
    });

    document.getElementById('btnDelete').addEventListener('click', () => {
      if (selectedPaths.size === 0) return alert('Ничего не выбрано');
      if (selectedPaths.has('/root')) return alert('Нельзя удалить корень');
      if (!confirm('Удалить выбранные элементы?')) return;
      const toDelete = Array.from(selectedPaths).sort((a,b) => b.length - a.length);
      for (const p of toDelete) {
        const info = findParentAndIndex(p);
        if (!info) continue;
        info.parent.children.splice(info.index, 1);
      }
      selectedPaths.clear();
      saveFS();
      refreshTree();
    });

    document.getElementById('btnDeleteSelected').addEventListener('click', () => {
      document.getElementById('btnDelete').click();
    });

    document.getElementById('btnMoveSelected').addEventListener('click', () => {
      if (selectedPaths.size === 0) return alert('Ничего не выбрано');
      const dest = prompt('Путь папки назначения (например /root/docs):', lastSelectedPath || '/root');
      if (!dest) return;
      const destNode = findNodeByPath(dest);
      if (!destNode || destNode.type !== 'folder') return alert('Папка назначения не найдена');
      const toMove = Array.from(selectedPaths).sort((a,b) => b.length - a.length);
      let movedAny = false;
      for (const src of toMove) {
        if (src === dest) continue;
        if (src.startsWith(dest + '/')) continue;
        const ok = moveNode(src, dest);
        if (ok) movedAny = true;
      }
      if (movedAny) {
        selectedPaths.clear();
        saveFS();
        refreshTree();
      } else alert('Ничего не перемещено');
    });

    /*************************************************************************
     * Search
     *************************************************************************/
    function searchFS(query, node = fileSystem, path = '') {
      const results = [];
      const curPath = path + '/' + node.name;
      if (node.name.toLowerCase().includes(query.toLowerCase())) results.push({ node, path: curPath });
      if (node.type === 'folder' && Array.isArray(node.children)) {
        node.children.forEach(child => results.push(...searchFS(query, child, curPath)));
      }
      return results;
    }

    searchInput.addEventListener('input', (e) => {
      const q = e.target.value.trim();
      if (!q) { refreshTree(); return; }
      const res = searchFS(q);
      treeRoot.innerHTML = '';
      if (res.length === 0) { treeRoot.innerHTML = '<div class="empty">Ничего не найдено</div>'; return; }
      res.forEach(r => {
        const item = document.createElement('div');
        item.className = 'node';
        item.innerHTML = '<div style="width:18px"></div>';
        const icon = createIcon(r.node.type === 'folder' ? 'icon-folder' : 'icon-txt');
        item.appendChild(icon);
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = r.path;
        item.appendChild(label);
        item.addEventListener('click', () => {
          selectedPaths.clear();
          selectedPaths.add(r.path);
          updateSelectionVisuals();
          renderBulkInfo();
          lastSelectedPath = r.path;
          lastSelectedNode = r.node;
          pathBar.textContent = 'Путь: ' + r.path;
          renderBreadcrumb(r.path);
          if (r.node.type === 'file') viewer.innerHTML = '<div class="meta">Файл: ' + r.path + '</div><div class="file-content">' + (r.node.content || '') + '</div>';
          else viewer.innerHTML = '<div class="meta">Папка: ' + r.path + '</div><div class="empty">Папка выбрана</div>';
        });
        treeRoot.appendChild(item);
      });
    });

    document.getElementById('btnClearSearch').addEventListener('click', () => { searchInput.value = ''; refreshTree(); });

    /*************************************************************************
     * Export / Import
     *************************************************************************/
    document.getElementById('btnExport').addEventListener('click', () => {
      const dataStr = JSON.stringify(fileSystem, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'filesystem.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    importInput.addEventListener('change', (e) => {
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = function(ev){
        try {
          const parsed = JSON.parse(ev.target.result);
          if (!parsed || parsed.type !== 'folder') { alert('JSON должен описывать корневую папку с type: "folder"'); return; }
          if (!confirm('Заменить текущую файловую систему импортируемой?')) return;
          fileSystem = parsed;
          saveFS();
          refreshTree();
          alert('Импорт завершён');
        } catch (err) { alert('Ошибка парсинга JSON: ' + err.message); }
      };
      reader.readAsText(f, 'utf-8');
      importInput.value = '';
    });

    /*************************************************************************
     * Editor + undo/redo + autosave + hotkeys
     *************************************************************************/
    function ensureHistoryFor(path) { if (!editHistory[path]) editHistory[path] = { stack: [], pos: -1 }; }
    function pushHistory(path, value) {
      ensureHistoryFor(path);
      const h = editHistory[path];
      if (h.pos < h.stack.length - 1) h.stack = h.stack.slice(0, h.pos + 1);
      h.stack.push(value); h.pos = h.stack.length - 1;
      if (h.stack.length > 200) { h.stack.shift(); h.pos = h.stack.length - 1; }
    }
    function undo(path) { ensureHistoryFor(path); const h = editHistory[path]; if (h.pos > 0) { h.pos--; return h.stack[h.pos]; } return null; }
    function redo(path) { ensureHistoryFor(path); const h = editHistory[path]; if (h.pos < h.stack.length - 1) { h.pos++; return h.stack[h.pos]; } return null; }

    function openEditorForSelected() {
      if (selectedPaths.size === 0) return alert('Ничего не выбрано');
      if (selectedPaths.size > 1) return alert('Редактирование работает только для одного файла');
      const path = Array.from(selectedPaths)[0];
      const node = findNodeByPath(path);
      if (!node) return alert('Ничего не выбрано');
      if (node.type !== 'file') return alert('Выберите файл');
      editorTextarea.value = node.content || '';
      modalPath.textContent = path;
      editorModal.style.display = 'block';
      pushHistory(path, editorTextarea.value);
      updateUndoRedoButtons();
      autosaveHint.textContent = AUTOSAVE_INTERVAL > 0 ? `Автосохранение: каждые ${AUTOSAVE_INTERVAL/1000}s` : 'Автосохранение: выключено';
      setTimeout(() => editorTextarea.focus(), 50);
      startAutosave();
    }

    function closeEditor() { stopAutosave(); editorModal.style.display = 'none'; }

    function startAutosave() {
      stopAutosave();
      if (AUTOSAVE_INTERVAL > 0) {
        autosaveTimer = setInterval(() => {
          const path = Array.from(selectedPaths)[0];
          const node = findNodeByPath(path);
          if (!node || node.type !== 'file') return;
          const current = editorTextarea.value;
          if (node.content !== current) {
            node.content = current;
            pushHistory(path, current);
            saveFS();
            updateUndoRedoButtons();
            console.log('Автосохранено', path);
          }
        }, AUTOSAVE_INTERVAL);
      }
    }

    function stopAutosave() { if (autosaveTimer) { clearInterval(autosaveTimer); autosaveTimer = null; } }

    function updateUndoRedoButtons() {
      const path = Array.from(selectedPaths)[0];
      const h = editHistory[path];
      const btnUndo = document.getElementById('btnUndo');
      const btnRedo = document.getElementById('btnRedo');
      if (!h || h.pos <= 0) btnUndo.disabled = true; else btnUndo.disabled = false;
      if (!h || h.pos >= h.stack.length - 1) btnRedo.disabled = true; else btnRedo.disabled = false;
    }

    document.getElementById('btnSaveEdit').addEventListener('click', () => {
      const path = Array.from(selectedPaths)[0];
      const node = findNodeByPath(path);
      if (!node) return alert('Ничего не выбрано');
      if (node.type !== 'file') return alert('Выбранный узел не файл');
      node.content = editorTextarea.value;
      pushHistory(path, node.content);
      saveFS();
      refreshTree();
      viewer.innerHTML = '<div class="meta">Файл: ' + path + '</div><div class="file-content">' + (node.content || '') + '</div>';
      closeEditor();
    });

    document.getElementById('btnCancelEdit').addEventListener('click', () => closeEditor());
    document.getElementById('btnUndo').addEventListener('click', () => { const path = Array.from(selectedPaths)[0]; const val = undo(path); if (val !== null) { editorTextarea.value = val; updateUndoRedoButtons(); } });
    document.getElementById('btnRedo').addEventListener('click', () => { const path = Array.from(selectedPaths)[0]; const val = redo(path); if (val !== null) { editorTextarea.value = val; updateUndoRedoButtons(); } });

    modalBackdrop.addEventListener('click', (e) => { if (e.target === modalBackdrop) closeEditor(); });

    document.addEventListener('keydown', (e) => {
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      const ctrl = isMac ? e.metaKey : e.ctrlKey;
      if (editorModal.style.display === 'block') {
        if (ctrl && e.key.toLowerCase() === 's') { e.preventDefault(); document.getElementById('btnSaveEdit').click(); }
        else if (ctrl && e.key.toLowerCase() === 'z') { e.preventDefault(); document.getElementById('btnUndo').click(); }
        else if (ctrl && (e.key.toLowerCase() === 'y' || (isMac && e.shiftKey && e.key.toLowerCase() === 'z'))) { e.preventDefault(); document.getElementById('btnRedo').click(); }
        else if (e.key === 'Escape') { e.preventDefault(); closeEditor(); }
      } else {
        if (ctrl && e.key.toLowerCase() === 's') { e.preventDefault(); saveFS(); console.log('Saved (Ctrl+S)'); }
        else if (e.key === 'Delete') { if (selectedPaths.size > 0) document.getElementById('btnDeleteSelected').click(); }
      }
    });

    let inputThrottle = null;
    editorTextarea.addEventListener('input', () => {
      if (inputThrottle) clearTimeout(inputThrottle);
      inputThrottle = setTimeout(() => {
        const path = Array.from(selectedPaths)[0];
        if (!path) return;
        pushHistory(path, editorTextarea.value);
        updateUndoRedoButtons();
      }, 800);
    });

    /*************************************************************************
     * Context menu implementation
     *************************************************************************/
    function showContextMenu(x, y, targetPath) {
      ctxMenu.style.display = 'block';
      ctxMenu.style.left = x + 'px';
      ctxMenu.style.top = y + 'px';
      ctxMenu.setAttribute('data-target', targetPath);
    }

    function hideContextMenu() {
      ctxMenu.style.display = 'none';
      ctxMenu.removeAttribute('data-target');
    }

    document.addEventListener('click', (e) => {
      if (!ctxMenu.contains(e.target)) hideContextMenu();
    });

    ctxMenu.addEventListener('click', (e) => {
      const action = e.target.getAttribute('data-action');
      const target = ctxMenu.getAttribute('data-target');
      hideContextMenu();
      if (!action || !target) return;
      // ensure selection includes target
      if (!selectedPaths.has(target)) {
        selectedPaths.clear();
        selectedPaths.add(target);
        updateSelectionVisuals();
        renderBulkInfo();
      }
      if (action === 'new-file') document.getElementById('btnNewFile').click();
      else if (action === 'new-folder') document.getElementById('btnNewFolder').click();
      else if (action === 'rename') document.getElementById('btnRename').click();
      else if (action === 'delete') document.getElementById('btnDelete').click();
      else if (action === 'move') document.getElementById('btnMoveSelected').click();
    });

    /*************************************************************************
     * Selection helpers and initial UI
     *************************************************************************/
    function updateSelectionAfterRefresh() {
      flattenedList = flattenTree();
      updateSelectionVisuals();
      renderBulkInfo();
    }

    // ensure selection visuals after refresh
    const origRefresh = refreshTree;
    refreshTree = function() {
      flattenedList = flattenTree();
      treeRoot.innerHTML = '';
      renderTree(fileSystem, treeRoot, '');
      const node = findNodeByPath(lastSelectedPath);
      if (!node) clearViewer();
      else { pathBar.textContent = 'Путь: ' + lastSelectedPath; renderBreadcrumb(lastSelectedPath); }
      updateSelectionVisuals();
      renderBulkInfo();
    };

    // initial load
    loadFS();
    refreshTree();

    /*************************************************************************
     * Small UX: hide drag ghost on mouse move to follow cursor (visual only)
     *************************************************************************/
    document.addEventListener('drag', (e) => {
      if (dragGhost.style.display === 'block') {
        dragGhost.style.left = (e.clientX + 12) + 'px';
        dragGhost.style.top = (e.clientY + 12) + 'px';
      }
    });

    document.addEventListener('dragend', () => { dragGhost.style.display = 'none'; });

    /*************************************************************************
     * End
     *************************************************************************/
  </script>
</body>
</html>
